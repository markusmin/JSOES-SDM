---
title: "FISH 556: Final Project"
author: "Markus Min"
date: "`r Sys.Date()`"
output:
  pdf_document: default
---

## Overview

For this exercise, we will be using the SPDE method to model spatial random variables.


```{r chunk-options, message = FALSE, echo = FALSE, warning = FALSE}
# set chunk options
knitr::opts_chunk$set(message = FALSE, echo = FALSE, warning = FALSE)
```


```{r load-libraries-reformat-data}
library(tidyverse)
library(here)
library(readxl)
library(janitor)
library(sf)
library(sdmTMB)
library(TMB)
library(rnaturalearth)
library(sdmTMBextra)
library(fmesher)
library(lubridate)
library(geosphere)
library(geos)

#### Species data ####
jsoes <- clean_names(read_excel(here::here("Data", "Markus_Min_Trawl_CTD_Chl_Nuts_Thorson_Scheuerell_5.2.24_FINAL.xlsx")))

species_column_names <- colnames(jsoes)[32:ncol(jsoes)]

# change nmi to km to keep units consistent
jsoes %>% 
  mutate(km_from_shore = nmi_from_shore * 1.852) -> jsoes

jsoes %>% 
  pivot_longer(., cols = all_of(species_column_names), values_to = "n_per_km", names_to = "species") %>% 
  mutate(n = n_per_km*trawl_dist_km) -> jsoes_long


#### Spatial data ####
usa_spdf <- st_read("/Users/markusmin/Documents/ESA_RF_2021/map_files/USA_adm0.shp")
# load BC
CAN_spdf <- st_read("/Users/markusmin/Documents/ESA_RF_2021/map_files/canada/lpr_000b16a_e.shp")
BC_spdf <- filter(CAN_spdf, PRENAME == "British Columbia")
BC_proj <- st_transform(BC_spdf, crs = 4326)


# crop them to our desired area
US_west_coast <- sf::st_crop(usa_spdf,
    c(xmin = -126, ymin = 44, xmax = -123, ymax = 48.5))

BC_coast <- sf::st_crop(BC_proj,
    c(xmin = -126, ymin = 44, xmax = -123, ymax = 48.5))



# convert both shapefiles to a different projection (UTM zone 10) so that they can be plotted with the sdmTMB output
UTM_zone_10_crs <- 32610

US_west_coast_proj <- sf::st_transform(US_west_coast, crs = UTM_zone_10_crs)
BC_coast_proj <- sf::st_transform(BC_coast, crs = UTM_zone_10_crs)

# make this projection into kilometers
US_west_coast_proj_km <- st_as_sf(US_west_coast_proj$geometry/1000, crs = UTM_zone_10_crs)
BC_coast_proj_km <- st_as_sf(BC_coast_proj$geometry/1000, crs = UTM_zone_10_crs)
```

```{r create_basemap}
# create base map
survey_area_basemap_km <- ggplot(US_west_coast_proj_km) +
  geom_sf() +
  geom_sf(data = BC_coast_proj_km) +
  # coord_sf(ylim = c(4922.052, 5342.052), xlim = c(334.8638, 404.8638)) +
  # coord_sf(ylim = c(44,48.5),  xlim = c(-126, -123)) +
  ylab("Latitude")+
  xlab("Longitude")+
  theme(plot.background = element_rect(fill = "white"),
        panel.background = element_rect(fill="white", color = "black"),
        panel.border = element_rect(colour = "black", fill=NA, size=1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = c(0.14, 0.2),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        axis.ticks = element_blank(),
        axis.text = element_blank())
  # temporary fix for lat/long on axes to just get rid of them - start here to actually fix: https://forum.posit.co/t/converting-axes-to-lat-lon/27181

survey_area_basemap_km

survey_area_basemap <- ggplot(US_west_coast) +
  geom_sf() +
  geom_sf(data = BC_coast) +
  coord_sf(ylim = c(44,48.5),  xlim = c(-126, -123)) +
  scale_x_continuous(breaks = c(124,125,126)) +
  ylab("Latitude")+
  xlab("Longitude")+
  theme(plot.background = element_rect(fill = "white"),
        panel.background = element_rect(fill="white", color = "black"),
        panel.border = element_rect(colour = "black", fill=NA, size=1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = c(0.14, 0.2),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12))
```


## JSOES data preparation for TMB
```{r prep-data}
# for now, let's drop any data that's missing lat/longs
jsoes_long <- filter(jsoes_long, !(is.na(mid_lat)))

# Drop any samples that don't have temperature data (we could interpolate both of these later)
jsoes_long <- filter(jsoes_long, !(is.na(x3m_temp_c)))



# Add UTM coordinates to get an equal distance projection and get lat/longs
utm_crs <- get_crs(jsoes_long, c("mid_long", "mid_lat")) # check that

jsoes_long <- add_utm_columns(
  jsoes_long,
  ll_names = c("mid_long", "mid_lat"),
  ll_crs = 4326,
  utm_names = c("Lon.km", "Lat.km"),
  utm_crs = utm_crs,
  units = c("km")
)


# Change Lon.km and Lat.km columns to X and Y to avoid problems later
jsoes_long %>% 
  dplyr::rename(X = Lon.km, Y = Lat.km) -> jsoes_long




# Subset data for individual species
csyis <- subset(jsoes_long, species == "chinook_salmon_yearling_interior_sp")
coho <- subset(jsoes_long, species == "coho_salmon_yearling")
water_jellies <- subset(jsoes_long, species == "water_jelly")



# quick check
hist(csyis$n_per_km)
summary(csyis$n_per_km)
hist(coho$n_per_km)
summary(coho$n_per_km)
hist(water_jellies$n_per_km)
summary(water_jellies$n_per_km)
```



```{r load-reformat-SST}
SST1 <- read.csv(here::here("Data", "noaacrwsstDaily_9bdb_17ce_0aa0.csv"), skip = 1)
SST2 <- read.csv(here::here("Data", "noaacrwsstDaily_36e3_7cb3_1109.csv"), skip = 1)
SST3 <- read.csv(here::here("Data", "noaacrwsstDaily_519c_f955_0fea.csv"), skip = 1)
SST4 <- read.csv(here::here("Data", "noaacrwsstDaily_727c_5c10_e6a0.csv"), skip = 1)
SST5 <- read.csv(here::here("Data", "noaacrwsstDaily_1176_fc5f_53d2.csv"), skip = 1)
SST6 <- read.csv(here::here("Data", "noaacrwsstDaily_ae0c_9197_083f.csv"), skip = 1)
SST7 <- read.csv(here::here("Data", "noaacrwsstDaily_fe4f_9c9c_442e.csv"), skip = 1)

SST1 %>% 
  bind_rows(., SST2, SST3, SST4, SST5, SST6, SST7) -> SST

SST %>% 
  dplyr::rename(time = UTC, latitude = degrees_north, longitude = degrees_east, SST = degree_C) -> SST
SST %>% 
  mutate(time = ymd_hms(time)) %>% 
  mutate(day_of_month = mday(time)) %>% 
  mutate(year = year(time)) %>% 
  mutate(julian = yday(time))-> SST

table(SST$day_of_month)


# Looks good to me! Now just need to resolve CRS conflicts
ggplot(data = subset(SST, year == 2010), aes(x = longitude, y = latitude, color = SST)) +
  geom_point()

# Convert SST to UTM zone 10
# st_as_sf(SST, coords = c("latitude", "longitude"), crs = "4326") -> SST_sf
st_as_sf(SST, coords = c("longitude", "latitude"), crs = 4326) -> SST_sf
US_west_coast

sf::st_transform(SST_sf, crs = UTM_zone_10_crs) -> SST_sf_proj

SST_plots <- survey_area_basemap +
  geom_sf(data = SST_sf_proj, aes(color = SST)) +
  scale_color_viridis_c(option = "A")+
  facet_wrap(~year, nrow = 3) +
  theme(legend.position = c(0.95, 0.1))

ggsave(here::here("figures", "SST_plots.png"), plot = SST_plots, height = 12, width = 17)
```


```{r create-survey-prediction-grid}
# Create a survey grid from scratch
# Make sure that it aligns with our SST

# only keep one year, since that's all we need to make a grid
SST_sf_proj %>% 
  filter(year == 2000) -> SST_sf_proj_2000

st_as_sf(SST_sf_proj_2000$geometry/1000, crs = UTM_zone_10_crs) -> SST_sf_proj_km_2000

SST_sf_proj_km_2000$dist_shore <- as.numeric(st_distance(SST_sf_proj_km_2000, US_west_coast_proj_km))


# 100 km offshore is the max, then 20 km north/south of limits of survey region
# The vast majority of stations are within 60 km of shore, but there are just a couple that are further out in the Columbia River Plume up to 83 km from shore
# We also want to exclude values that are within 0.5 km of shore, because these
# don't have measureable SST values (they're basically on shore)
hist(jsoes_long$km_from_shore)

SST_sf_proj_km_2000 %>% 
  filter(dist_shore <= 100 & dist_shore >= 0.5) -> grid_within_100km_shore


ggplot(SST_sf_proj_km_2000) +
  geom_sf()
ggplot(grid_within_100km_shore) +
  geom_sf()


min(jsoes_long$Y) -> min_Y
max(jsoes_long$Y) -> max_Y


survey_domain <- st_crop(grid_within_100km_shore, xmin = 0, xmax = 100000, ymin=min_Y-20, ymax=max_Y+20)

st_difference(survey_domain, US_west_coast_proj_km) -> survey_domain

# manually remove sections for strait, hood canal (and other inland waters), Grays Harbor, Willapa Bay, Columbia River estuary
strait <- st_as_sfc(st_bbox(c(xmin=-124.65, xmax=-122, ymin=47.9375, ymax=49), crs = "WGS84"))
strait_proj <- sf::st_transform(strait, crs = UTM_zone_10_crs)
strait_proj_km <- st_as_sf(strait_proj/1000, crs = UTM_zone_10_crs)

inland_waters <- st_as_sfc(st_bbox(c(xmin=-123.5, xmax=-120, ymin=44, ymax=49.5), crs = "WGS84"))
inland_waters_proj <- sf::st_transform(inland_waters, crs = UTM_zone_10_crs)
inland_waters_proj_km <- st_as_sf(inland_waters_proj/1000, crs = UTM_zone_10_crs)

grays_harbor <- st_as_sfc(st_bbox(c(xmin=-124.15, xmax=-123.6, ymin=46.83, ymax=47.09), crs = "WGS84"))
grays_harbor_proj <- sf::st_transform(grays_harbor, crs = UTM_zone_10_crs)
grays_harbor_proj_km <- st_as_sf(grays_harbor_proj/1000, crs = UTM_zone_10_crs)

willapa_bay <- st_as_sfc(st_bbox(c(xmin=-124.06, xmax=-123.5, ymin=46.34, ymax=46.8), crs = "WGS84"))
willapa_bay_proj <- sf::st_transform(willapa_bay, crs = UTM_zone_10_crs)
willapa_bay_proj_km <- st_as_sf(willapa_bay_proj/1000, crs = UTM_zone_10_crs)

estuary <- st_as_sfc(st_bbox(c(xmin=-124.02, xmax=-123.5, ymin=46.12, ymax=46.35), crs = "WGS84"))
estuary_proj <- sf::st_transform(estuary, crs = UTM_zone_10_crs)
estuary_proj_km <- st_as_sf(estuary_proj/1000, crs = UTM_zone_10_crs)

survey_domain %>% 
  st_difference(., strait_proj_km) %>% 
  st_difference(., inland_waters_proj_km) %>% 
  st_difference(., grays_harbor_proj_km) %>% 
  st_difference(., willapa_bay_proj_km) %>% 
  st_difference(., estuary_proj_km) -> survey_domain

# Create a concave hull around points
st_concave_hull(st_union(survey_domain), ratio = 0.1) -> survey_domain_polygon

ggplot(survey_domain_polygon) +
  geom_sf()

ggplot(survey_domain) +
  geom_sf()

survey_area_basemap_km +
  geom_sf(data = survey_domain_polygon)
```


```{r plot-data}
plot_distribution <- function(data){
  # create facet_wrap plot for distribution across all years
  data %>% 
    mutate(encounter = ifelse(n_per_km == 0, "zero", "non-zero")) -> data
  
  survey_area_basemap +
      geom_point(data = data, aes(x = mid_long, y = mid_lat, size = n_per_km, color = encounter),
                 alpha = 0.5) +
    scale_color_manual(values = c("zero" = "#fc9272", "non-zero" = "#2ca25f")) +
    facet_wrap(~year, nrow = 3) +
    theme(legend.position = c(0.95, 0.1)) -> species_distribution_plot
  
  return(species_distribution_plot)
}

csyis_dist_plot <- plot_distribution(data = csyis)
coho_dist_plot <- plot_distribution(data = coho)
water_jellies_dist_plot <- plot_distribution(data = water_jellies)


ggsave(here::here("figures", "csyis_distribution_plot.png"), plot = csyis_dist_plot, height = 12, width = 17)
ggsave(here::here("figures", "coho_distribution_plot.png"), plot = coho_dist_plot, height = 12, width = 17)
ggsave(here::here("figures", "water_jellies_distribution_plot.png"), plot = water_jellies_dist_plot, height = 12, width = 17)

```



```{r create-prediction-grid}
# Take SST grid and intersect with survey domain
SST_sf_proj %>% 
  mutate(geometry = geometry/1000) %>% 
  st_set_crs(UTM_zone_10_crs) %>% 
  st_intersection(survey_domain_polygon) %>% 
  dplyr::select(SST, year, geometry)-> SST_survey_domain

# add in distance from shore
SST_survey_domain %>% 
  mutate(sf_dist_shore = as.numeric(st_distance(geometry, US_west_coast_proj_km))) %>% 
  # I'm not sure why we have to filter again here, but make sure to exclude points that are 
  # > 100 km from shore and < 0.5 km from shore - maybe some rounding errors?
  filter(sf_dist_shore <= 100 & sf_dist_shore >= 0.5) -> survey_domain_cov

# plot it - looks good!
ggplot(survey_domain_cov) + geom_sf()

# Now let's reformat it to be in the form of a data frame that we can use to predict
as.data.frame(st_coordinates(survey_domain_cov)) -> survey_domain_cov_coords
survey_predict_grid <- data.frame(X = survey_domain_cov_coords$X,
                                  Y = survey_domain_cov_coords$Y,
                                  SST = survey_domain_cov$SST,
                                  year = survey_domain_cov$year,
                                  dist_shore = as.numeric(survey_domain_cov$sf_dist_shore))

# rescale prediction grid
survey_predict_grid %>% 
  mutate(SST_scaled = as.numeric(scale(SST)),
         dist_shore_scaled = as.numeric(scale(dist_shore))) -> survey_predict_grid
```


```{r create-mesh}

# Create mesh for SPDE
inla_mesh <- fmesher::fm_mesh_2d_inla(
  loc = cbind(csyis$X, csyis$Y), # coordinates
  cutoff = 10 # minimum triangle edge length
)


spde <- fm_fem( inla_mesh, 
                order = 2 )

# create projection matrix from vertices to samples
# Because all species have the same sampling intensity, we can just use one of the DFs here
A_is = fm_evaluator(inla_mesh, loc = as.matrix(data.frame(X = csyis$X, Y = csyis$Y)))$proj$A

# create projection matrix from vertices to prediction grid
survey_domain_cov_grid <- filter(survey_domain_cov, year == 1998)

A_gs = fm_evaluator( inla_mesh, loc=st_coordinates(survey_domain_cov_grid))$proj$A
# A_gs = fm_evaluator( inla_mesh, loc=st_coordinates(st_centroid(survey_grid_df)))$proj$A

# Make the sdmTMB mesh
# csyis_mesh <- make_mesh(csyis, xy_cols = c("X", "Y"), cutoff = 10)
# plot(csyis_mesh)
# for consistency, use the inla_mesh for all
mesh_sdmTMB <- make_mesh(csyis, xy_cols = c("X", "Y"), mesh = inla_mesh)

# confirm that the meshes used for bespoke TMB and sdmTMB are the same
# plot(csyis_mesh)
plot(inla_mesh)
plot(mesh_sdmTMB)

png(here::here("figures", "mesh.png"), width=4, height=6, res=200, units="in")
plot(mesh_sdmTMB)
dev.off()
# plot(mesh)
# Let's use the inla mesh, it looks most reasonable (and very close to the default sdmTMB make_mesh one)
```




## Models without covariates

The first model that I fit is a model with main effects for space and year. This model assumes that there is an effect of year and an effect of space, but these factors do not interact. This is in effect our null model.

This model has the following equation:

$$
log(d_{s,t}) \sim \beta_t + \omega_s \\
\omega \sim \textrm{MVN}(\textbf{0},\Sigma) \\
$$

Where:
- $s$ is the station
- $t$ is the year
- $d$ is the density of a species caught in a tow
- $\beta_t$ is the median density in year t
- $\omega_s$ is the density for location $s$ relative to the median location that is typical across years
- $\Sigma$ is the spatial variance. Because we are using the SPDE method, $\Sigma$ is $Q_{spde}^{-1}$.


```{r fit-model1-TMB, eval = FALSE}
compile(here::here("analysis", "jsoes_null_sdm.cpp"))
dyn.load( dynlib(here::here("analysis", "jsoes_null_sdm")))

Data = list( "D_i"= csyis$n_per_km, "t_i" = csyis$year - min(csyis$year), 
             "n_t" = length(unique(csyis$year)),
             "A_is"=A_is, "A_gs"=A_gs, "M0"=spde$c0, "M1"=spde$g1, "M2"=spde$g2 )
Params = list( "beta_t"=rep(0, length(unique(csyis$year))), "ln_tau"=0, "ln_kappa"=0, 
               "ln_phi" = 0, "finv_power" = 0, "omega_s"=rnorm(nrow(spde$c0)))
null_Obj = MakeADFun( data=Data, parameters=Params, random= c("omega_s"),
                 DLL = "jsoes_null_sdm")

# Optimize
null_Opt = nlminb( start=null_Obj$par, obj=null_Obj$fn, grad=null_Obj$gr )
null_Opt$SD = sdreport( null_Obj, bias.correct=TRUE )
null_report = null_Obj$report()
```

```{r fit-model-1-sdmTMB}
# Fit sdmTMB with effect of year and effect of space, no interaction (model 1, null model)
jsoes_null_sdmTMB <- sdmTMB(n_per_km ~ 0 + as.factor(year),
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "off",
                         family = tweedie(link = "log"))
```

The second model adds a term for a spatio-temporal variable, $\epsilon_{s,t}$.

This model has the following equation:

$$
log(d_{s,t}) \sim \beta_t + \omega_s + \epsilon_{s,t}\\
\omega \sim \textrm{MVN}(\textbf{0},\sigma_\omega^2\textbf{R}_\omega) \\
\epsilon_{t} \sim \textrm{MVN}(\textbf{0},\sigma_\epsilon^2\textbf{R}_\epsilon) \\
$$

Where:
- $s$ is the station
- $t$ is the year
- $d$ is the density of a species caught in a tow
- $\beta_t$ is the median density in year t
- $\omega_s$ is the density for location $s$ relative to the median location that is typical across years
- $\epsilon_{s,t}$ is a spatio-temporal variable that describes the effect of each combination of year and location on density
- $\textbf{R}_\omega$ = $\textbf{R}_\epsilon$ is the spatial correlation. These are the same because the correlation structure is set up using the SPDE method.
- $\sigma_\omega$ is the spatial variance. This is controlled by the parameter $\tau_\omega$ in the SPDE calculation.
- $\sigma_\epsilon$ is the spatio-temporal variance. This is controlled by the parameter $\tau_\epsilon$ in the SPDE calculation.

However, because we are using the SPDE method to model a precision matrix for our grid that will then be shared for both the spatial ($\omega_s$) and spatio-temoral ($\epsilon_{s,t}) terms, $\sigma_\omega^2\textbf{R}_\omega$ =  $\sigma_\epsilon^2\textbf{R}_\epsilon$ = $\Sigma$ = $Q_{spde}^{-1}$.


```{r fit-model2-TMB, eval = FALSE}
compile(here::here("analysis", "jsoes_st_sdm.cpp"))
dyn.load( dynlib(here::here("analysis", "jsoes_st_sdm")))

Data = list( "D_i"= csyis$n_per_km, "t_i" = csyis$year - min(csyis$year), 
             "n_t" = length(unique(csyis$year)),
             "A_is"=A_is, "A_gs"=A_gs, "M0"=spde$c0, "M1"=spde$g1, "M2"=spde$g2 )
Params = list( "beta_t"=rep(0, length(unique(csyis$year))), 
               "ln_tau_omega"=0, "ln_tau_epsilon"=0,
               "ln_kappa"=0, "ln_phi" = 0, 
               "finv_power" = 0, "omega_s"=rnorm(nrow(spde$c0)),
               "epsilon_st"=matrix(0, nrow=nrow(spde$c0), ncol=Data$n_t))

st_Obj = MakeADFun( data=Data, parameters=Params, random= c("omega_s", "epsilon_st"),
                 DLL = "jsoes_st_sdm")

# Optimize
st_Opt = nlminb( start=st_Obj$par, obj=st_Obj$fn, grad=st_Obj$gr )
# Opt$SD = sdreport( Obj, bias.correct=TRUE )
st_report = st_Obj$report()
```

```{r fit-model-2-sdmTMB}
# Fit sdmTMB with effect of year and effect of space and spatio-temporal effect
jsoes_st_sdmTMB <- sdmTMB(n_per_km ~ 0 + as.factor(year),
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "iid",
                         family = tweedie(link = "log"))

# check that they're the same
st_report$beta_t
jsoes_st_sdmTMB
```


The third model now models the spatio-temporal variable, $\epsilon_{s,t}$, as a temporally autocorrelated process.

This model has the following equation:

$$
log(d_{s,t}) \sim \beta_t + \omega_s + \epsilon_{s,t}\\
\omega \sim \textrm{MVN}(\textbf{0},\sigma_\omega^2\textbf{R}_\omega) \\
\epsilon_{t} \sim \textrm{MVN}(\textbf{0},\sigma_\epsilon^2\textbf{R}_\epsilon) \\
$$

Where:
- $s$ is the station
- $t$ is the year
- $d$ is the density of a species caught in a tow
- $\beta_t$ is the median density in year t
- $\omega_s$ is the density for location $s$ relative to the median location that is typical across years
- $\epsilon_{s,t}$ is a spatio-temporal variable that describes the effect of each combination of year and location on density
- $\textbf{R}_\omega$ = $\textbf{R}_\epsilon$ is the spatial correlation. These are the same because the correlation structure is set up using the SPDE method.
- $\sigma_\omega$ is the spatial variance. This is controlled by the parameter $\tau_\omega$ in the SPDE calculation.
- $\sigma_\epsilon$ is the spatio-temporal variance. This is controlled by the parameter $\tau_\epsilon$ in the SPDE calculation.

However, because we are using the SPDE method to model a precision matrix for our grid that will then be shared for both the spatial ($\omega_s$) and spatio-temoral ($\epsilon_{s,t}) terms, $\sigma_\omega^2\textbf{R}_\omega$ =  $\sigma_\epsilon^2\textbf{R}_\epsilon$ = $\Sigma$ = $Q_{spde}^{-1}$.


```{r fit-model3-TMB, eval = FALSE}
compile(here::here("analysis", "jsoes_stac_sdm.cpp"))
dyn.load( dynlib(here::here("analysis", "jsoes_stac_sdm")))

Data = list( "D_i"= csyis$n_per_km, "t_i" = csyis$year - min(csyis$year), 
             "n_t" = length(unique(csyis$year)),
             "A_is"=A_is, "A_gs"=A_gs, "M0"=spde$c0, "M1"=spde$g1, "M2"=spde$g2 )
Params = list( "beta_t"=rep(0, length(unique(csyis$year))), 
               "ln_tau_omega"=0, "ln_tau_epsilon"=0,
               "ln_kappa"=0, "logit_rhoE" = 0,  "ln_phi" = 0, 
               "finv_power" = 0, "omega_s"=rnorm(nrow(spde$c0)),
               "epsilon_st"=matrix(0, nrow=nrow(spde$c0), ncol=Data$n_t))

stac_Obj = MakeADFun( data=Data, parameters=Params, random= c("omega_s", "epsilon_st"),
                 DLL = "jsoes_stac_sdm")

# Optimize
stac_Opt = nlminb( start=stac_Obj$par, obj=stac_Obj$fn, grad=stac_Obj$gr )
# Opt$SD = sdreport( Obj, bias.correct=TRUE )
stac_report = stac_Obj$report()
```

```{r fit-model-3-sdmTMB}
# Fit sdmTMB with effect of year and effect of space and spatio-temporal effect
jsoes_stac_sdmTMB <- sdmTMB(n_per_km ~ 0 + as.factor(year),
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "ar1",
                         family = tweedie(link = "log"))
```


The fourth model now models the temporal main effect, $\beta_t$, as a temporally autocorrelated process.
```{r fit-model4-TMB, eval = FALSE}
compile(here::here("analysis", "jsoes_tempac_sdm.cpp"))
dyn.load( dynlib(here::here("analysis", "jsoes_tempac_sdm")))

Data = list( "D_i"= csyis$n_per_km, "t_i" = csyis$year - min(csyis$year), 
             "n_t" = length(unique(csyis$year)),
             "A_is"=A_is, "A_gs"=A_gs, "M0"=spde$c0, "M1"=spde$g1, "M2"=spde$g2 )
Params = list( "beta_t"=rep(0, length(unique(csyis$year))), 
               "ln_tau_omega"=0, "ln_tau_epsilon"=0,
               "ln_kappa"=0, "logit_rhoB" = 0,  "ln_phi" = 0, 
               "finv_power" = 0, "ln_sigmaB" = 0, "omega_s"=rnorm(nrow(spde$c0)),
               "epsilon_st"=matrix(0, nrow=nrow(spde$c0), ncol=Data$n_t))

tempac_Obj = MakeADFun( data=Data, parameters=Params, random= c("omega_s", "epsilon_st", "beta_t"),
                 DLL = "jsoes_tempac_sdm")

# Optimize
tempac_Opt = nlminb( start=tempac_Obj$par, obj=tempac_Obj$fn, grad=tempac_Obj$gr )
# Opt$SD = sdreport( tempac_Obj, bias.correct=TRUE )
tempac_report = tempac_Obj$report()
```

```{r fit-model-4-sdmTMB, eval = FALSE}
# Fit sdmTMB with effect of year and effect of space and spatio-temporal effect
jsoes_tempac_sdmTMB <- sdmTMB(n_per_km ~ 0 + as.factor(year),
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         time_varying = ~ 0 + as.factor(year),
                         time_varying_type = "ar1",
                         spatial = "on",
                         spatiotemporal = "iid",
                         family = tweedie(link = "log"),
                         silent = FALSE)

# This doesn't work - it runs the optimizer but then gives this error message:
# Error in solve.default(h, g) : system is computationally singular: reciprocal condition number = 1.84191e-29
```

The fifth model now models both the spatio-temporal variable, $\epsilon_{s,t}$, and the temporal main effect, $\beta_t$, as temporally autocorrelated processes.

```{r fit-model5-TMB, eval = FALSE}
compile(here::here("analysis", "jsoes_stac_tempac_sdm.cpp"))
dyn.load( dynlib(here::here("analysis", "jsoes_stac_tempac_sdm")))

Data = list( "D_i"= csyis$n_per_km, "t_i" = csyis$year - min(csyis$year), 
             "n_t" = length(unique(csyis$year)),
             "A_is"=A_is, "A_gs"=A_gs, "M0"=spde$c0, "M1"=spde$g1, "M2"=spde$g2 )
Params = list( "beta_t"=rep(0, length(unique(csyis$year))), 
               "ln_tau_omega"=0, "ln_tau_epsilon"=0,
               "ln_kappa"=0, "logit_rhoB" = 0, "logit_rhoE" = 0, "ln_phi" = 0, 
               "finv_power" = 0, "ln_sigmaB" = 0, "omega_s"=rnorm(nrow(spde$c0)),
               "epsilon_st"=matrix(0, nrow=nrow(spde$c0), ncol=Data$n_t))

stac_tempac_Obj = MakeADFun( data=Data, parameters=Params, random= c("omega_s", "epsilon_st", "beta_t"),
                 DLL = "jsoes_stac_tempac_sdm")

# Optimize
stac_tempac_Opt = nlminb( start=stac_tempac_Obj$par, obj=stac_tempac_Obj$fn, grad=stac_tempac_Obj$gr )
# Opt$SD = sdreport( stac_tempac_Obj, bias.correct=TRUE )
stac_tempac_report = stac_tempac_Obj$report()
```

```{r fit-model-5-sdmTMB, eval = FALSE}
# Fit sdmTMB with effect of year and effect of space and spatio-temporal effect
jsoes_stac_tempac_sdmTMB <- sdmTMB(n_per_km ~ 0 + as.factor(year),
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         time_varying = ~ 0 + as.factor(year),
                         time_varying_type = "ar1",
                         spatial = "on",
                         spatiotemporal = "ar1",
                         family = tweedie(link = "log"),
                         silent = FALSE)

# This doesn't work - it runs the optimizer but then gives this error message:
# Error in solve.default(h, g) : system is computationally singular: reciprocal condition number = 1.63961e-31
```

## Models without covariates: Cross-validation


```{r}
# Set up for parallelization
library(future)
plan(multisession, workers = 4)

# Model 1: Null model
jsoes_null_sdmTMB_cv <- sdmTMB_cv(n_per_km ~ 0 + as.factor(year),
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "off",
                         family = tweedie(link = "log"),
                         k_folds = 4)


# Model 2: Spatiotemporal, IID
jsoes_st_sdmTMB_cv <- sdmTMB_cv(n_per_km ~ 0 + as.factor(year),
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "iid",
                         family = tweedie(link = "log"),
                         k_folds = 4)


# Model 3: Spatiotemporal, AR1
jsoes_stac_sdmTMB_cv <- sdmTMB_cv(n_per_km ~ 0 + as.factor(year),
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "ar1",
                         family = tweedie(link = "log"),
                         k_folds = 4)

# Compare models
AIC(jsoes_null_sdmTMB)
AIC(jsoes_st_sdmTMB)
AIC(jsoes_stac_sdmTMB)



jsoes_null_sdmTMB_cv$sum_loglik
jsoes_st_sdmTMB_cv$sum_loglik
jsoes_stac_sdmTMB_cv$sum_loglik


```


## Predictions + projections

```{r predict-to-grid, eval = FALSE}

# create new grid
# create a polygon based off the mesh boundaries
# CRS 32610 is UTM zone 10N, which is the UTM zone that corresponds to the survey area
st_as_sf(as.data.frame(mesh_sdmTMB$loc_xy), coords = c("X", "Y"),
         crs = UTM_zone_10_crs) -> mesh_sf

# to get a convex hull, need to group all points together into one polygon
mesh_sf %>% 
  summarise(geometry = st_combine(geometry)) -> mesh_sf


new_poly <- st_convex_hull(mesh_sf)
plot(new_poly)
st_crs(new_poly)

# remove land from polygon
coast_proj <- sf::st_transform(US_west_coast_proj$geometry, crs = UTM_zone_10_crs)


poly <- st_difference(new_poly, coast_proj)
st_crs(poly) 
plot(poly)
st_bbox(poly)


# create a grid within the polygon using the raster package
# resolution <- 2000 # poly is in meters; 2000 is pretty fine: 2000m x 2000m = 4 km2
resolution <- 10 # poly is in km I believe; 5 x 5 = 25 km2
r <- raster::raster(as(poly, "Spatial"), resolution = resolution)
rr <- raster::rasterize(as(poly, "Spatial"), r, getCover = TRUE)
# plot(rr)

# convert to data frame and calculate grid cell area for each row
grid <- as.data.frame(raster::rasterToPoints(rr))
grid$area <- grid$layer * resolution * resolution # meters squared
grid <- dplyr::filter(grid, area > 0) |> 
  dplyr::select(-layer)

grid %>% 
  dplyr::rename(X = x, Y = y) -> grid

# grid$X <- grid$x / 1000
# grid$Y <- grid$y / 1000
grid$area.km <- grid$area / 1e03


# plot to see a display of grid cell areas coded by color
ggplot(grid, aes(X, Y, colour = area.km)) +
  geom_tile(width = 10, height = 10, fill = NA) + # in meters
  scale_colour_viridis_c(direction = -1) +
  geom_point(size = 0.5) +
  coord_fixed()

grid_yrs <- replicate_df(grid, "year", unique(csyis$year))


# predict to grid using jsoes_st_sdmTMB
predict_st = predict(jsoes_st_sdmTMB, newdata = grid_yrs, return_tmb_object = FALSE)

```

```{r create-map}
survey_area_basemap +
  geom_tile(data = subset(predict_st, year == 2000), aes(x = X*1000, y = Y*1000, fill = exp(est)))

test_plot <- survey_area_basemap +
  geom_tile(data = predict_st, aes(x = X*1000, y = Y*1000, fill = exp(est))) +
  # scale_fill_viridis_c( trans = "sqrt",
  #                       # trim extreme high values to make spatial variation more visible
  #                       na.value = "yellow", limits = c(0, quantile(exp(predict_st$est), 0.995))) +
  scale_fill_viridis_c() +
  facet_wrap(~year) +
  theme_light() +
  labs(fill = "Predicted\nabundance") +
  labs(x = "Longitude", y = "Latitude")+
  ggtitle("Spatiotemporal model, no covariates")

ggsave(here::here("figures", "test_plot.png"), plot = test_plot, height = 20, width = 15)
```


## Models with covariates

#### Covariate exploration

Primary candidates for covariates are the following:

- Station depth (stn_depth_m)
- Nautical miles from shore (nmi_from_shore)
- SST (x3m_temp_c)


Future covariates could include many of the other nutrient/chlorophyll information that is also collected
- Chlorophyll (x3m_Chl_ugL)

```{r covariate-exploration}
ggplot(jsoes, aes(x = as.factor(nmi_from_shore), y = chinook_salmon_yearling_interior_sp)) +
         geom_boxplot()

ggplot(jsoes, aes(x = stn_depth_m, y = chinook_salmon_yearling_interior_sp)) +
         geom_point()

ggplot(jsoes, aes(x = x3m_temp_c, y = chinook_salmon_yearling_interior_sp)) +
         geom_point()

# look at correlation between nmi_from_shore and stn_depth_m
ggplot(jsoes, aes(x = nmi_from_shore, y = stn_depth_m)) +
         geom_point()
cor(jsoes$nmi_from_shore, jsoes$stn_depth_m)
# yeah pretty correlated, should probably only choose one.
# I am going to say that for now, I think that we'll include distance from shore,
# since for a pelagic species that seems to make more ecological sense

```


We also need to know the date range to use for SST for interpolation.
```{r}
jsoes %>% 
  mutate(julian_day = yday(sample_date)) -> jsoes

hist(jsoes$julian_day)
# for simplicity (and to keep our dataset a reasonable size), let's take the mean day
round(mean(jsoes$julian_day))
# corresponds to june 24 (on non-leap years)
```






Based on our model selection process for the selection of spatial and temporal effects, we have now added covariates into our best model (spatial effect, spatiotemporal random fields that are AR1).


$$
log(d_{s,t}) \sim \beta_t + \textbf{x}_{s,t}\gamma + \omega_s + \epsilon_{s,t} \\
\omega \sim \textrm{MVN}(\textbf{0},\sigma_w^2\textbf{R}_w) \\
\epsilon_t \sim \textrm{MVN}(\textbf{0},\sigma_\epsilon^2\textbf{R}_\epsilon)
$$

Where:
- $s$ is the location
- $t$ is the year
- $d$ is the density of a species caught in a tow
- $\beta_t$ is the median density in year t
- $\textbf{x}_{s,t}$ is a vector containing the values of the covariates (SST and distance from shore) at location $s$ in year $t$
- $\gamma$ is a vector containing the parameters that describe the fixed effects of the covariates
- $\omega_s$ is the density for location $s$ relative to the median location that is typical across years
- $\epsilon_{s,t}$ is a spatio-temporal variable that describes the effect of each combination of year and location on density
- $\textbf{R}_\omega$ = $\textbf{R}_\epsilon$ is the spatial correlation. These are the same because the correlation structure is set up using the SPDE method.
- $\sigma_\omega$ is the spatial variance. This is controlled by the parameter $\tau_\omega$ in the SPDE calculation.
- $\sigma_\epsilon$ is the spatio-temporal variance. This is controlled by the parameter $\tau_\epsilon$ in the SPDE calculation.

However, because we are using the SPDE method to model a precision matrix for our grid that will then be shared for both the spatial ($\omega_s$) and spatio-temoral ($\epsilon_{s,t}) terms, $\sigma_\omega^2\textbf{R}_\omega$ =  $\sigma_\epsilon^2\textbf{R}_\epsilon$ = $\Sigma$ = $Q_{spde}^{-1}$.


$\textbf{x}_{s,t}$ includes the following parameters whose effects are described in $\gamma$:
- SST (degrees celsisus)
- Distance from shore in km

To get predicted estimates for the survey grid, we need the values of covariates at all poinst within our projection grid.

- Distance from shore can be calculate using sf, to get the distance from the polygon
- SST: Need multiple queries, to account for leap years
  - Query from ERDDAP: https://coastwatch.noaa.gov/erddap/griddap/noaacrwsstDaily.html
  - time (UTC): 
    - start 1998-06-24T12:00:00Z / 2000-06-24T12:00:00Z / 2004-06-24T12:00:00Z / 2008-06-24T12:00:00Z / 2012-06-24T12:00:00Z / 2016-06-24T12:00:00Z / 2020-06-24T12:00:00Z
    - stride 365
    - stop 1999-06-24T12:00:00Z / 2003-06-24T12:00:00Z / 2007-06-24T12:00:00Z / 2011-06-24T12:00:00Z / 2015-06-24T12:00:00Z / 2019-06-24T12:00:00Z / 2023-06-24T12:00:00Z
  - latitude (degrees north):
    - start 44
    - stride 1
    - stop 48.5
  - longitude (degrees east):
    - start -127
    - stride 1
    - stop -123
  - Grid variables: analysed_sst (analysed sea surface temperature, degree_C) 
  - download as CSV
  
  
  
```{r calculate_dist_shore, eval = FALSE}
dplyr::select(csyis, station, km_from_shore, X, Y) -> csyis_spatial
st_as_sf(csyis_spatial, coords = c("X", "Y"), crs = UTM_zone_10_crs) -> csyis_sf
st_distance(csyis_sf, US_west_coast_proj_km) -> csyis_dist_shore
csyis$sf_dist_shore <- as.numeric(csyis_dist_shore)


dplyr::select(coho, station, km_from_shore, X, Y) -> coho_spatial
st_as_sf(coho_spatial, coords = c("X", "Y"), crs = UTM_zone_10_crs) -> coho_sf
st_distance(coho_sf, US_west_coast_proj_km) -> coho_dist_shore
coho$sf_dist_shore <- as.numeric(coho_dist_shore)


dplyr::select(water_jellies, station, km_from_shore, X, Y) -> water_jellies_spatial
st_as_sf(water_jellies_spatial, coords = c("X", "Y"), crs = UTM_zone_10_crs) -> water_jellies_sf
st_distance(water_jellies_sf, US_west_coast_proj_km) -> water_jellies_dist_shore
water_jellies$sf_dist_shore <- as.numeric(water_jellies_dist_shore)






# confirm that these are reasonable, based on points from survey
# they're similar - but not identical
hist(as.numeric(csyis$sf_dist_shore)-csyis_spatial$km_from_shore)
# and they're pretty biased - the distances calculated using sf tend to be smaller
# Let's just use the sf distance from shore calculated for both prediction grid and
# the samples themselves
```


Now, we need to z-score data to make prepare it for model fitting
```{r rescale-data}
# rescale data
csyis %>% 
  mutate(SST_scaled = as.numeric(scale(x3m_temp_c)),
         dist_shore_scaled = as.numeric(scale(sf_dist_shore))) -> csyis

coho %>% 
  mutate(SST_scaled = as.numeric(scale(x3m_temp_c)),
         dist_shore_scaled = as.numeric(scale(sf_dist_shore))) -> coho

water_jellies %>% 
  mutate(SST_scaled = as.numeric(scale(x3m_temp_c)),
         dist_shore_scaled = as.numeric(scale(sf_dist_shore))) -> water_jellies

```




```{r fit-cov-model-TMB, eval = FALSE}
# for distance - just pull from prediction grid, for a single year
distance_projection_vector <- as.numeric(filter(survey_predict_grid, year == 1998)$dist_shore_scaled)

# for SST - take prediction grid, add SST with locations as rows and years as column
survey_predict_grid %>% 
  dplyr::select(-dist_shore) %>% 
  pivot_wider(names_from = year, values_from = SST_scaled) %>% 
  dplyr::select(-c(X, Y)) %>% 
  as.matrix() -> temperature_projection_matrix


# sanity check that all our covariates and projection matrices are the same dimensions
length(distance_projection_vector)
dim(temperature_projection_matrix)
dim(A_gs)
# very nice!

# look at projection histograms
hist(distance_projection_vector)
hist(temperature_projection_matrix)

# look at data histograms
hist(csyis$n_per_km)
hist(csyis$SST_scaled)
hist(csyis$dist_shore_scaled)

summary(csyis$SST_scaled)
summary(csyis$dist_shore_scaled)

compile(here::here("analysis", "jsoes_st_cov_sdm.cpp"))
dyn.load( dynlib(here::here("analysis", "jsoes_st_cov_sdm")))

Data = list( "D_i"= csyis$n_per_km, "t_i" = csyis$year - min(csyis$year), 
             "temp_i" = csyis$SST_scaled, "dist_i" = csyis$dist_shore_scaled,
             "dist_g" = distance_projection_vector, "temp_gt" = temperature_projection_matrix, 
             "n_t" = length(unique(csyis$year)),
             "A_is"=A_is, "A_gs"=A_gs, "M0"=spde$c0, "M1"=spde$g1, "M2"=spde$g2 )
Params = list( "beta_t"=rep(0, length(unique(csyis$year))), 
               "beta_temp" = 0, "beta_dist" = 0,
               "ln_tau_omega"=0, "ln_tau_epsilon"=0,
               "ln_kappa"=0, "ln_phi" = 0, 
               "finv_power" = 0, "omega_s"=rnorm(nrow(spde$c0)),
               "epsilon_st"=matrix(0, nrow=nrow(spde$c0), ncol=Data$n_t))

st_cov_Obj = MakeADFun( data=Data, parameters=Params, random= c("omega_s", "epsilon_st"),
                 DLL = "jsoes_st_cov_sdm")


# Optimize
st_cov_Opt = nlminb( start=st_cov_Obj$par, obj=st_cov_Obj$fn, grad=st_cov_Obj$gr )
# Opt$SD = sdreport( Obj, bias.correct=TRUE )
st_cov_report = st_cov_Obj$report()
```

```{r fit-cov-model-sdmTMB}
# Fit sdmTMB with effect of year and effect of space and spatio-temporal effect

### CHINOOK INTERIOR SPRING
csyis_stac_cov_sdmTMB <- sdmTMB(n_per_km ~ 0 + as.factor(year) + SST_scaled + dist_shore_scaled,
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "ar1",
                         family = tweedie(link = "log"))

sanity(csyis_stac_cov_sdmTMB)
AIC(csyis_stac_cov_sdmTMB)


# check for alignment
csyis_stac_cov_sdmTMB
st_cov_report$beta_t
st_cov_report$beta_dist
st_cov_report$beta_temp
# the same! Now fit for other species

# Cross validation for comparison with other models
set.seed(556)
csyis_stac_cov_sdmTMB_cv <- sdmTMB_cv(n_per_km ~ 0 + as.factor(year) + SST_scaled + dist_shore_scaled,
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "ar1",
                         family = tweedie(link = "log"),
                         k_folds = 4)

csyis_stac_cov_sdmTMB_cv$sum_loglik


### COHO YEARLINGS
coho_stac_cov_sdmTMB <- sdmTMB(n_per_km ~ 0 + as.factor(year) + SST_scaled + dist_shore_scaled,
                         data = coho,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "ar1",
                         family = tweedie(link = "log"))

sanity(coho_stac_cov_sdmTMB)
AIC(coho_stac_cov_sdmTMB)



### WATER JELLIES
water_jellies_stac_cov_sdmTMB <- sdmTMB(n_per_km ~ 0 + as.factor(year) + SST_scaled + dist_shore_scaled,
                         data = water_jellies,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "ar1",
                         family = tweedie(link = "log"))

sanity(water_jellies_stac_cov_sdmTMB)
AIC(water_jellies_stac_cov_sdmTMB)


# Fit another model, with splines for depth and distance
jsoes_stac_cov_splines_sdmTMB <- sdmTMB(n_per_km ~ 0 + as.factor(year) + s(SST_scaled) + s(dist_shore_scaled),
                         data = csyis,
                         mesh = mesh_sdmTMB,
                         time = "year",
                         spatial = "on",
                         spatiotemporal = "ar1",
                         family = tweedie(link = "log"))

sanity(jsoes_stac_cov_splines_sdmTMB)
AIC(jsoes_stac_cov_splines_sdmTMB)
# doesn't pass sanity check, and it looks like smooth term for distance has a SD that went to zero
# and the smooth term for SST has a SD that got really big

```


```{r export-model-tables}

csyis_model_selection_table <- data.frame(model = c("Null", "Spatiotemporal", "Spatiotemporal, AR1", "Spatiotemporal, AR1 + SST + Dist"),
                                          AIC = c(AIC(jsoes_null_sdmTMB), AIC(jsoes_st_sdmTMB), 
                                                  AIC(jsoes_stac_sdmTMB), AIC(csyis_stac_cov_sdmTMB)),
                                          cv_total_log_likelihood = c(jsoes_null_sdmTMB_cv$sum_loglik, jsoes_st_sdmTMB_cv$sum_loglik, 
                                                                      jsoes_stac_sdmTMB_cv$sum_loglik, csyis_stac_cov_sdmTMB_cv$sum_loglik))

write.csv(csyis_model_selection_table, here::here("figures", "csyis_model_selection_table.csv"))

csyis_stac_cov_sdmTMB
coho_stac_cov_sdmTMB
water_jellies_stac_cov_sdmTMB

model_parameters_table <- data.frame(species = c("Yearling Chinook", 
                                                 "Yearling Coho",
                                                 "Water jellies"),
                                     SST_est = c(-0.23, 0.31, -0.07),
                                     SST_SE = c(0.13, 0.09, 0.1),
                                     dist_shore_est = c(-0.25, -0.55, -0.67),
                                     dist_shore_SE = c(0.23, 0.15, 0.15))


write.csv(model_parameters_table, here::here("figures", "model_parameters_table.csv"))
```



```{r predict-with-covariates}
survey_predict_grid
# check for no missing values in prediction grid
which(is.na(survey_predict_grid))


csyis_stac_cov_sdmTMB_pred <- predict(csyis_stac_cov_sdmTMB, newdata = survey_predict_grid)
coho_stac_cov_sdmTMB_pred <- predict(coho_stac_cov_sdmTMB, newdata = survey_predict_grid)
water_jellies_stac_cov_sdmTMB_pred <- predict(water_jellies_stac_cov_sdmTMB, newdata = survey_predict_grid)

# plot the predictions
plot_density_predictions <- function(predictions){
  # I'm sure I could dial the geom_tile argument in a bit better based on the actual grid size of 0.05 lat x 0.05 long, but oh well... according to NOAA these tiles should be approx 4 km wide by 6 km tall
density_predictions_map <- survey_area_basemap_km +
  geom_tile(data = predictions, aes(x = X, y = Y, fill = exp(est)),
            width = 7, height = 7) +
  scale_fill_viridis_c( trans = "sqrt",
                        # trim extreme high values to make spatial variation more visible
                        na.value = "yellow", limits = c(0, quantile(exp(predictions$est), 0.995)),
                        name = "Predicted density\n(n per km)") +
  facet_wrap(~year, nrow = 3) +
  theme(axis.text = element_blank(),
        legend.position = c(0.95, 0.1))

return(density_predictions_map)
  
}

csyis_prediction_map <- plot_density_predictions(predictions = csyis_stac_cov_sdmTMB_pred)
coho_prediction_map <- plot_density_predictions(predictions = coho_stac_cov_sdmTMB_pred)
water_jellies_prediction_map <- plot_density_predictions(predictions = water_jellies_stac_cov_sdmTMB_pred)



ggsave(here::here("figures", "csyis_prediction_map.png"), plot = csyis_prediction_map, height = 12, width = 17)
ggsave(here::here("figures", "coho_prediction_map.png"), plot = coho_prediction_map, height = 12, width = 17)
ggsave(here::here("figures", "water_jellies_prediction_map.png"), plot = water_jellies_prediction_map, height = 12, width = 17)
```


```{r model_diagnostics}
csyis$model_residuals <- residuals(csyis_stac_cov_sdmTMB)

csyis_stac_cov_sdmTMB_residuals_plot <- survey_area_basemap_km +
  geom_point(data = csyis, aes(X, Y, col = model_residuals)) +
  scale_colour_gradient2() +
  facet_wrap(~year, nrow = 3) +
  theme(legend.position = c(0.95, 0.1))

ggsave(here::here("figures", "csyis_stac_cov_sdmTMB_residuals_plots.png"), plot = csyis_stac_cov_sdmTMB_residuals_plot, height = 12, width = 17)

coho$model_residuals <- residuals(coho_stac_cov_sdmTMB)

coho_stac_cov_sdmTMB_residuals_plot <- survey_area_basemap_km +
  geom_point(data = coho, aes(X, Y, col = model_residuals)) +
  scale_colour_gradient2() +
  facet_wrap(~year, nrow = 3) +
  theme(legend.position = c(0.95, 0.1))

ggsave(here::here("figures", "coho_stac_cov_sdmTMB_residuals_plots.png"), plot = coho_stac_cov_sdmTMB_residuals_plot, height = 12, width = 17)

water_jellies$model_residuals <- residuals(water_jellies_stac_cov_sdmTMB)

water_jellies_stac_cov_sdmTMB_residuals_plot <- survey_area_basemap_km +
  geom_point(data = water_jellies, aes(X, Y, col = model_residuals)) +
  scale_colour_gradient2() +
  facet_wrap(~year, nrow = 3) +
  theme(legend.position = c(0.95, 0.1))

ggsave(here::here("figures", "water_jellies_stac_cov_sdmTMB_residuals_plots.png"), plot = water_jellies_stac_cov_sdmTMB_residuals_plot, height = 12, width = 17)
```



## Area-weighted indices of abundance


```{r index_standardization_function}
# In our case, each cell is the same size: 0.05 lat x 0.05 lon
# which... maybe is not all the same in km
# based on calculations from earlier they're approximately 4 x 6 km = 24 km area

# get predictions, with return_tmb_object = TRUE

csyis_stac_cov_sdmTMB_pred_TMB <- predict(csyis_stac_cov_sdmTMB, newdata = survey_predict_grid, return_tmb_object = TRUE)
coho_stac_cov_sdmTMB_pred_TMB <- predict(coho_stac_cov_sdmTMB, newdata = survey_predict_grid, return_tmb_object = TRUE)
water_jellies_stac_cov_sdmTMB_pred_TMB <- predict(water_jellies_stac_cov_sdmTMB, newdata = survey_predict_grid, return_tmb_object = TRUE)

csyis_index_of_abundance <- get_index(csyis_stac_cov_sdmTMB_pred_TMB, area = 24, bias_correct = TRUE)
coho_index_of_abundance <- get_index(coho_stac_cov_sdmTMB_pred_TMB, area = 24, bias_correct = TRUE)
water_jellies_index_of_abundance <- get_index(water_jellies_stac_cov_sdmTMB_pred_TMB, area = 24, bias_correct = TRUE)

```

```{r plot_indices}
csyis_abundance_plot <- ggplot(csyis_index_of_abundance, aes(year, est)) + geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +
  xlab('Year') + ylab('Estimated individuals')

coho_abundance_plot <- ggplot(coho_index_of_abundance, aes(year, est)) + geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +
  xlab('Year') + ylab('Estimated individuals')

water_jellies_abundance_plot <- ggplot(water_jellies_index_of_abundance, aes(year, est)) + geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +
  xlab('Year') + ylab('Estimated individuals')

ggsave(here::here("figures", "csyis_abundance_plot.png"), plot = csyis_abundance_plot, height = 6, width = 8)
ggsave(here::here("figures", "coho_abundance_plot.png"), plot = coho_abundance_plot, height = 6, width = 8)
ggsave(here::here("figures", "water_jellies_abundance_plot.png"), plot = water_jellies_abundance_plot, height = 6, width = 8)
```




## Species distribution overlap

Based on our best model, we will apply the local index of collocation metric of predator-prey overlap. This measures the co-occurrence by estimating the correlation of predator and prey densities, and uses the following equation:
$$
\frac{\sum\limits_{i=1}^n (p\_pred_i*p\_prey_i) }{\sqrt{\sum\limits_{i=1}^n p\_pred_i^2 * \sum\limits_{i=1}^n p\_prey_i^2}}

$$

This can also be used to measure competition.


```{r calculate_collocation}
collocation_metric <- function(grid1, grid2){
  dplyr::select(grid1, X, Y, year, est) %>% 
    dplyr::rename(est1 = est) %>% 
    bind_cols(., grid2$est) %>% 
    dplyr::rename(est2 = `...5`) %>% 
    # convert to normal space
    mutate(est1 = exp(est1)) %>% 
    mutate(est2 = exp(est2)) -> combined_grid
  
  combined_grid %>% 
    mutate(predxprey = est1 * est2) -> combined_grid
  
  # calculate for each year
  combined_grid %>% 
    group_by(year) %>% 
    summarise(numerator = sum(predxprey)) -> numerator_by_year
  
  combined_grid %>% 
    group_by(year) %>% 
    summarise(denominator = sqrt(sum(est1^2)*sum(est2^2))) -> denominator_by_year
  
  numerator_by_year %>% 
    left_join(denominator_by_year, by = "year") %>% 
    mutate(index = numerator/denominator) %>% 
    dplyr::select(year, index) -> index_by_year
  

  return(index_by_year)
  
}

competition_index <- collocation_metric(grid1 = csyis_stac_cov_sdmTMB_pred, grid2 = coho_stac_cov_sdmTMB_pred)
predator_prey_index <- collocation_metric(grid1 = csyis_stac_cov_sdmTMB_pred, grid2 = water_jellies_stac_cov_sdmTMB_pred)
```


```{r plot_overlap}
competition_overlap_plot <- ggplot(competition_index, aes(year, index)) + geom_line() +
  xlab('Year') + ylab('Collocation Index')

predator_prey_overlap_plot <- ggplot(predator_prey_index, aes(year, index)) + geom_line() +
  xlab('Year') + ylab('Collocation Index')


ggsave(here::here("figures", "csyis_coho_overlap_plot.png"), plot = competition_overlap_plot, height = 6, width = 8)
ggsave(here::here("figures", "csyis_water_jellies_overlap_plot.png"), plot = predator_prey_overlap_plot, height = 6, width = 8)
```
